import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { RootState } from '../../../app/store';

import { IShow } from '../../models/Show.model';
import { ShowService } from '../../services/Shows.service';

export interface IShows {
    category: string;
    value: null | Array<IShow>;
    status: 'idle' | 'loading' | 'failed';
}

const initialState: IShows = {
    category: '',
    value: null,
    status: 'idle',
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const searchShowsAsync = createAsyncThunk(
    'shows/fetchShowsByCategory',
    async (category: string) => {
        const response = await ShowService.getByCategory(category);
        console.log('searchShowsAsync', response);
        // The value we return becomes the `fulfilled` action payload
        const shows: Array<IShow> = [];
        for(let i = 0; i < response.length; i++){
            const item = response[i];
            const show: IShow = {
                id: item.show.id,
                url: item.show.url,
                name: item.show.name,
                type: item.show.type,
                language: item.show.language,
                genres: item.show.genres,
                status: item.show.status,
                runtime: item.show.runtime,
                averageRuntime: item.show.averageRuntime,
                premiered: item.show.premiered,
                officialSite: item.show.officialSite,
                rating: item.show.rating.average,
                image: item.show.image ? {
                    medium: item.show.image.medium,
                    original: item.show.image.original,
                } : null,
                summary: item.show.summary
            };

            shows.push(show);
        }

        return {
            shows,
            category
        };
    }
);

export const showsSlice = createSlice({
    name: 'shows',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
    
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
        .addCase(searchShowsAsync.pending, (state) => {
            state.status = 'loading';
        })
        .addCase(searchShowsAsync.fulfilled, (state, action) => {
            state.status = 'idle';
            state.value = action.payload.shows;
            state.category = action.payload.category;
        });
    },
});

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const getShows = (state: RootState) => state.shows.value;
export const getStatus = (state: RootState) => state.shows.status;


export default showsSlice.reducer;
